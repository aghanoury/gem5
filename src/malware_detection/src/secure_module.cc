#include "malware_detection/src/secure_module.hh"

#include <iostream>

#include "base/trace.hh"
#include "debug/SecureModule.hh"
#include "debug/SecureModuleCpp.hh"

namespace gem5
{

  // constructor
  SecureModule::SecureModule(const SecureModuleParams &params)
      : ClockedObject(params), waitingPortId(-1),
        cpuPort(params.name + ".cpu_side", this),
        memPort(params.name + ".mem_side", this),
        mem_issue_latency(params.mem_issue_latency),
        read_verif_tags_cycles(params.read_verif_tags_cycles),
        write_calc_tags_cycles(params.write_calc_tags_cycles),
        key_tag_cache_access_latency(params.key_tag_cache_access_latency),
        sm_cache_hitrate(params.sm_cache_hitrate),
        dram_avg_access_latency(params.dram_avg_access_latency),
        blocked(false),
        state(ModuleState::READY),
        requestQueue(params.request_queue_size),
        responseQueue(params.response_queue_size)
  // requestQueue(params.queue_size),
  {
    cpuWaiting = false;
    pendingRequest = false;
    pendingResponse = false;
    std::srand(0);
  }

  // unimplemented, nothing needs to be done here
  void SecureModule::startup() {}

  Port &SecureModule::getPort(const std::string &if_name, PortID idx)
  {
    DPRINTF(SecureModuleCpp, "getPort %s\n", if_name);

    if (if_name == "mem_side")
    {
      return memPort;
    }
    else if (if_name == "cpu_side")
    {
      return cpuPort;
    }
    else
    {
      // i don't really know what happens at this point...
      // tbd when a stack trace points here
      panic("returning neither a cpu nor mem port...");
      return ClockedObject::getPort(if_name, idx);
    }
  }

  AddrRangeList SecureModule::CPUSidePort::getAddrRanges() const
  {
    DPRINTF(SecureModuleCpp, "getAddrRanges\n");
    return owner->getAddrRanges();
  }

  bool SecureModule::CPUSidePort::sendPacket(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "Sending packet: %s\n", pkt->print());

    // If we can't send the packet across the port, store it for later.
    // logic for package trasmission should be minimal
    bool success = sendTimingResp(pkt);
    return success;
    // DPRINTF(SecureModuleCpp, "sendPacket return code: %s\n", success);
    // if (!success)
    // {
    //   blockedPacket = pkt;
    //   owner->cpuWaiting = true;
    //   DPRINTF(SecureModuleCpp, "setCpuWaiting\n");
    // }
    // else
    // {
    //   owner->cpuWaiting = false;
    //   owner->memPort.sendRetryResp();
    // }
    // return success;
  }

  bool SecureModule::CPUSidePort::sendPacketQueue()
  {
    DPRINTF(SecureModuleCpp, "sendPacketQueue\n");
    PacketPtr pkt = owner->responseQueue.front();
    bool succ = sendTimingResp(pkt);
    if (!succ) // return false, retry request will come later
    {
      DPRINTF(SecureModuleCpp, "❌ CPU denied packet %s\n", pkt->print());
    }
    else
    { // succesful send
      owner->responseQueue.pop();
      DPRINTF(SecureModuleCpp, "✅ CPU accepted packet %s\n", pkt->print());
      owner->handleMemRespRetry();
    }
    return succ;
  }
  // might deprecate
  void SecureModule::CPUSidePort::trySendRetry()
  {
    DPRINTF(SecureModuleCpp, "trySendRetry\n");
    if (needRetry && blockedPacket == nullptr)
    {
      // Only send a retry if the port is now completely free
      needRetry = false;
      DPRINTF(SecureModule, "Sending retry req for %d\n", id);
      sendRetryReq();
    }
  }

  void SecureModule::CPUSidePort::recvFunctional(PacketPtr pkt)
  {
    // DPRINTF(SecureModuleCpp, "recvFunctional\n");
    // Just forward to the memobj.
    return owner->handleFunctional(pkt);
  }

  bool SecureModule::CPUSidePort::recvTimingReq(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "➡️️recvTimingReq, pkt-> %s\n", pkt->print());
    return owner->handleRequest(pkt);
  }

  void SecureModule::CPUSidePort::recvRespRetry()
  {
    DPRINTF(SecureModuleCpp, "recvRespRetry\n");
    owner->pendingRequest = false;
    // owner->handleCpuRetry();
    sendPacketQueue(); // attempts to send the front packet of the queue
  }

  // PLAN TO DEPRECATE
  bool SecureModule::MemSidePort::sendPacket(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "sendPacket\n");
    bool succ = sendTimingReq(pkt);
    if (!succ) // return false, retry request will come later
    {
      owner->state = ModuleState::MEM_WAITING_RETRY;
      DPRINTF(SecureModuleCpp, "memory denied packet, entering state MEM_WAITING_RETRY\n");
      DPRINTF(SecureModuleCpp, "❌ Memory denied packet %s", pkt->print());
    }
    else
    { // succesful send
      owner->state = ModuleState::MEM_WAITING_RESPONSE;
      DPRINTF(SecureModuleCpp, "✅ Memory accepted packet %s\n", pkt->print());
    }
    return succ;
  }

  // similar to regular sendpacket, references request queue instead of a single packet
  bool SecureModule::MemSidePort::sendPacketQueue()
  {
    DPRINTF(SecureModuleCpp, "sendPacketQueue\n");
    DPRINTF(SecureModuleCpp, "requestQueue.size: %d\n", owner->requestQueue.size());
    PacketPtr pkt = owner->requestQueue.front();
    bool succ = sendTimingReq(pkt);
    if (!succ) // return false, retry request will come later
    {
      owner->state = ModuleState::MEM_WAITING_RETRY;
      DPRINTF(SecureModuleCpp, "memory denied packet, entering state MEM_WAITING_RETRY\n");
      DPRINTF(SecureModuleCpp, "❌ Memory denied packet %s", pkt->print());
    }
    else
    { // succesful send
      owner->state = ModuleState::MEM_WAITING_RESPONSE;
      owner->requestQueue.pop();
      DPRINTF(SecureModuleCpp, "✅ Memory accepted packet %s\n", pkt->print());
      owner->handleCpuReqRetry();
    }
    return succ;
  }

  bool SecureModule::MemSidePort::recvTimingResp(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "⬅️ recvTimingResp\n");
    return owner->handleResponse(pkt);
  }

  void SecureModule::MemSidePort::recvReqRetry()
  {
    DPRINTF(SecureModuleCpp, "recvReqRetry\n");
    DPRINTF(SecureModuleCpp, "Module state: %d\n", owner->state);
    owner->pendingResponse = false;
    // owner->handleMemRetry();
    // We should have a blocked packet if this function is called.
    // assert(blockedPacket != nullptr);
    sendPacketQueue();
  }

  void SecureModule::MemSidePort::recvRangeChange()
  {
    DPRINTF(SecureModuleCpp, "recvRangeChange\n");
    owner->sendRangeChange();
  }

  // secure module main methods
  void SecureModule::handleCpuReqRetry()
  {
    if (pendingRequest)
    {
      DPRINTF(SecureModuleCpp, "Sending CPU request retry\n");
      cpuPort.sendRetryReq();
      return;
    }
  }

  void SecureModule::handleMemRespRetry()
  {
    if (pendingResponse)
    {
      DPRINTF(SecureModuleCpp, "Sending MEM response retry\n");
      memPort.sendRetryResp();
      return;
    }
  }

  bool SecureModule::handleRequest(PacketPtr pkt)
  {
    DPRINTF(SecureModule, "%s for addr %#x\n", pkt->cmdString(), pkt->getAddr());
    DPRINTF(SecureModuleCpp, "handleRequest . pkt-type: %s for addr %#x\n", pkt->cmdString(), pkt->getAddr());
    // DPRINTF(SecureModuleCpp, "Module State: %d\n", state);
    // DPRINTF(SecureModuleCpp, "needsResponse: %d\n", pkt->needsResponse());

    // bool succ = enqueueRequest(pkt);
    bool succ = requestQueue.push(pkt);
    if (!succ)
    {
      DPRINTF(SecureModuleCpp, "enqueueRequest failed\n");
      pendingRequest = true;
    }
    else
    {
      // assert(pendingRequest == false);
      pendingRequest = false; // by virtue of the queue having space
      DPRINTF(SecureModuleCpp, "enqueueRequest success\n");
      // add to the event queue to process a request from the queue

      schedule(new EventFunctionWrapper([this]
                                        { memPort.sendPacketQueue(); },
                                        name() + ".accessEvent", true),
               clockEdge(mem_issue_latency) + curTick()); // TODO: update this hardcoded value to a param
    }
    return succ;

    {
      // switch (state)
      // {
      // case ModuleState::READY:
      //   cpuWaiting = false; // might not be the best place to put this
      //   return memPort.sendPacket(pkt);
      // default:
      //   // return memPort.sendPacket(pkt);
      //   cpuWaiting = true;
      //   return false;
      //   break;
      // }

      // panic("we reached this point when we should not have");
      // // state = ModuleState::CPU_REQ_BLOCKED;

      // // if we get a request while the module is currently busy handling other tasks
      // if (blocked)
      // {
      //   DPRINTF(SecureModuleCpp, "blocked\n");
      //   waiting = true;
      //   return false;
      // }

      // // depending on read or write, we need different procedures
      // if (pkt->isRead())
      // {
      //   DPRINTF(SecureModuleCpp, "isRead\n");
      // }
      // else if (pkt->isWrite())
      // {
      //   // if we get a write, block the module from further requests
      //   // the data is immediately sent to the memory side (with the incurred latency of just traveling through the module)
      //   // while a request is simulatenously sent to the secondary memory to fetch the keys and tags
      //   // during this time, we will block the module from further requests
      //   // of course, we're not actually issuing a request to the secondary memory
      //   // if the tags are in our approximate cache, we will only block for N cycles to access cache, verify, and write to the cache
      //   // if the tags are not in our approximate cache, we will block for 26ns to access the secondary memory, verify, and write to the cache

      //   // check if the keys/tags are in the cache (simulated with a random number chosen against the cache hit rate)
      //   // if the keys/tags are in the cache,
      //   DPRINTF(SecureModuleCpp, "isWrite\n");
      //   blocked = true;

      //   // choose a random number between 0 and 1
      //   // std::srand(std::time(0));

      //   double randomValue = static_cast<double>(std::rand()) / RAND_MAX;

      //   // cache hit rate
      //   int result = (randomValue < sm_cache_hitrate) ? 1 : 0;
      //   DPRINTF(SecureModuleCpp, "randomValue: %f < %f, %d\n", randomValue, sm_cache_hitrate, result);

      //   if (result)
      //   { // cache hit
      //     DPRINTF(SecureModuleCpp, "tag/key cache hit\n");
      //     // block for N cycles to access cache, verify, and write to the cache
      //     const Cycles total_delay = mem_issue_latency + key_tag_cache_access_latency + write_calc_tags_cycles;

      //     schedule(new EventFunctionWrapper([this, pkt]
      //                                       { unBlock(pkt); },
      //                                       name() + ".accessEvent", true),
      //              clockEdge(total_delay));
      //   }
      //   else
      //   {
      //     DPRINTF(SecureModuleCpp, "tag/key cache miss\n");
      //     // block for N cycles to access cache, verify, and write to the cache
      //     // const Cycles total_delay = mem_issue_latency + key_tag_cache_access_latency + write_verif_tags_cycles;

      //     schedule(new EventFunctionWrapper([this, pkt]
      //                                       { unBlock(pkt); },
      //                                       name() + ".accessEvent", true),
      //              clockEdge(mem_issue_latency + write_calc_tags_cycles) + curTick() + dram_avg_access_latency); // TODO: update this hardcoded value to a param
      //   }
      // }
      // else
      // {
      //   DPRINTF(SecureModuleCpp, "isOther\n");
      // }

      // // issue the write
      // schedule(new EventFunctionWrapper([this, pkt]
      //                                   { memPort.sendPacket(pkt); },
      //                                   name() + ".accessEvent", true),
      //          clockEdge(mem_issue_latency));

      // return true;
    }
  }

  bool SecureModule::handleResponse(PacketPtr pkt)
  {
    DPRINTF(SecureModule, "Got response for addr %#x\n", pkt->getAddr());
    DPRINTF(SecureModuleCpp, "handleResponse. pkt-type: %s\n", pkt->cmdString());

    {
      // // if the response is to a write, we need to add the extra latency for either a memory or cache write
      // // if there is a cache hit, we will add 0 additional latency for that write/recvT
      // // if
      // // delay the packet going back to the cpu
      // Cycles delay = Cycles(1);

      // // this is where we randomly choose a delay
      // std::srand(std::time(0));

      // // cache hit rate
      // double hit_rate = 0.7; // Change this to your desired probability

      // // Generate a random number between 0 and 1
      // double randomValue = static_cast<double>(std::rand()) / RAND_MAX;

      // // Choose 1 or 0 based on probability
      // int result = (randomValue < hit_rate) ? 1 : 0;

      // // Output the result
      // DPRINTF(SecureModuleCpp, "randomValue: %f\n", randomValue);
      // std::cout << "Randomly chosen value: " << result << std::endl;

      // what happens here is that the memory has sent a response,
      // but the previous response still hasn't been succesfully forwarded to the CPU
    }

    // we got here because memPort.recvTimingResp was called.
    // either we succesfully add pkt to respons queue or we return false to sender
    // and ask for a retry later when we're ready
    bool succ = responseQueue.push(pkt);
    if (!succ)
    {
      DPRINTF(SecureModuleCpp, "enqueueResponse failed\n");
      pendingResponse = true;
    }
    else
    {
      // assert(pendingResponse == false);
      pendingResponse = false; // by virtue of the queue having space
      DPRINTF(SecureModuleCpp, "enqueueResponse success\n");
      // add to the event queue to process a response from the queue
      // we don't need to delay the response packet so we add that call to the
      // event queue with no additional delay
      schedule(new EventFunctionWrapper([this]
                                        { cpuPort.sendPacketQueue(); },
                                        name() + ".accessEvent", true),
               curTick()); // TODO: update this hardcoded value to a param
    }
    return succ;

    {

      // switch (state)
      // {
      // case ModuleState::MEM_WAITING_RESPONSE:
      //   succ = cpuPort.sendPacket(pkt);
      //   if (succ)
      //   {
      //     state = ModuleState::READY;
      //     // execute the clearnReady one cycle later
      //     DPRINTF(SecureModuleCpp, "Moving to READY, scheduling cleanReady\n");
      //     schedule(new EventFunctionWrapper([this]
      //                                       { cleanReady(); },
      //                                       name() + ".accessEvent", true),
      //              curTick());
      //   }
      //   else
      //   {
      //     state = ModuleState::CPU_WAITING_RETRY;
      //   }
      //   break;

      // default:
      //   panic("should not get here");
      //   return false;
      // }
      // DPRINTF(SecureModuleCpp, "sendPacket return code: %s\n", succ);

      // // schedule(new EventFunctionWrapper([this, pkt]
      // //                                   { cpuPort.sendPacket(pkt); },
      // //                                   name() + ".accessEvent", true),
      // //          clockEdge(mem_issue_latency));
      // return succ;
    }
  }

  void SecureModule::unBlock(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "unBlock: waiting type %d\n", waiting);
    // DPRINTF(SecureModuleCpp, "unBlock. pkt-type: %s\n", pkt->cmdString());
    blocked = false;
    if (waiting)
    {
      cpuPort.sendRetryReq();
      waiting = false;
    }
  }

  // do we need these?
  bool SecureModule::enqueueRequest(PacketPtr pkt)
  {
  }

  bool SecureModule::enqueueResponse(PacketPtr pkt)
  {
  }

  void SecureModule::cleanReady()
  {
    DPRINTF(SecureModuleCpp, "cleanReady\n");
    // should not execute here if we are not in the ready state
    assert(state == ModuleState::READY);
    if (cpuWaiting)
    {
      DPRINTF(SecureModuleCpp, "sendingRetyReq\n");
      cpuPort.sendRetryReq();
    }
  }

  void SecureModule::handleFunctional(PacketPtr pkt)
  {
    // DPRINTF(SecureModuleCpp, "handleFunctional\n");
    // Just pass this on to the memory side to handle for now.
    memPort.sendFunctional(pkt);
  }

  AddrRangeList SecureModule::getAddrRanges() const
  {
    DPRINTF(SecureModuleCpp, "getAddrRanges\n");
    DPRINTF(SecureModule, "Sending new ranges\n");
    // Just use the same ranges as whatever is on the memory side.
    return memPort.getAddrRanges();
  }

  void SecureModule::sendRangeChange()
  {
    DPRINTF(SecureModuleCpp, "sendRangeChange\n");
    cpuPort.sendRangeChange();
    // for (auto &port : cpuPorts) {
    //   port.sendRangeChange();
    // }
  }

} // namespace gem5
