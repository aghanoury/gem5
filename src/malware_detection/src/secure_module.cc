#include "malware_detection/src/secure_module.hh"

#include <iostream>

#include "base/trace.hh"
#include "debug/SecureModule.hh"
#include "debug/SecureModuleCpp.hh"
#include "debug/SecureModuleCycles.hh"

namespace gem5
{

  // constructor
  SecureModule::SecureModule(const SecureModuleParams &params)
      : ClockedObject(params), waitingPortId(-1),
        cpuPort(params.name + ".cpu_side", this),
        memPort(params.name + ".mem_side", this),
        mem_issue_latency(params.mem_issue_latency),
        read_verif_tags_cycles(params.read_verif_tags_cycles),
        write_calc_tags_cycles(params.write_calc_tags_cycles),
        key_tag_cache_access_latency(params.key_tag_cache_access_latency),
        sm_cache_hitrate(params.sm_cache_hitrate),
        dram_avg_access_latency(params.dram_avg_access_latency),
        blocked(false),
        state(ModuleState::READY),
        requestQueue(params.request_queue_size),
        responseQueue(params.response_queue_size)
  // requestQueue(params.queue_size),
  {
    cpuWaiting = false;
    pendingRequest = false;
    pendingResponse = false;

    cpuBlocked = false;
    memBlocked = false;
    std::srand(0);
  }

  // unimplemented, nothing needs to be done here
  void SecureModule::startup()
  {
    DPRINTF(SecureModuleCpp, "startup\n");
    schedule(new EventFunctionWrapper([this]
                                      { cycle(); },
                                      name() + ".startupEvent", true),
             clockEdge(Cycles(1)));
  }

  // on every cycle, we check if we have any packets to send to the cpu or memory
  void SecureModule::cycle()
  {
    // print size of both queues and pending flags, all in one line
    DPRINTF(SecureModuleCycles, "requestQueue.size: %d, responseQueue.size: %d, pendingRequest: %d, pendingResponse: %d\n", requestQueue.size(), responseQueue.size(), pendingRequest, pendingResponse);

    if (!requestQueue.empty() && *std::get<1>(requestQueue.front()) == true)
    {
      DPRINTF(SecureModuleCpp, "requestQueue.front() is ready\n");
      memPort.sendPacketQueue();
    }
    // try to send repsonses
    if (!responseQueue.empty())
    {
      cpuPort.sendPacketQueue();
    }

    // other things that should just happen every cycle
    handleCpuReqRetry();
    handleMemRespRetry();

    // invoke on the next cycle, keep this going.
    // do we need to make sure this stops at some point?
    schedule(new EventFunctionWrapper([this]
                                      { cycle(); },
                                      name() + ".startupEvent", true),
             clockEdge(Cycles(1)));
  }

  Port &SecureModule::getPort(const std::string &if_name, PortID idx)
  {
    DPRINTF(SecureModuleCpp, "getPort %s\n", if_name);

    if (if_name == "mem_side")
    {
      return memPort;
    }
    else if (if_name == "cpu_side")
    {
      return cpuPort;
    }
    else
    {
      // i don't really know what happens at this point...
      // tbd when a stack trace points here
      panic("returning neither a cpu nor mem port...");
      return ClockedObject::getPort(if_name, idx);
    }
  }

  AddrRangeList SecureModule::CPUSidePort::getAddrRanges() const
  {
    DPRINTF(SecureModuleCpp, "getAddrRanges\n");
    return owner->getAddrRanges();
  }

  bool SecureModule::CPUSidePort::sendPacket(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "Sending packet: %s\n", pkt->print());

    // If we can't send the packet across the port, store it for later.
    // logic for package trasmission should be minimal
    bool success = sendTimingResp(pkt);
    return success;
    // DPRINTF(SecureModuleCpp, "sendPacket return code: %s\n", success);
    // if (!success)
    // {
    //   blockedPacket = pkt;
    //   owner->cpuWaiting = true;
    //   DPRINTF(SecureModuleCpp, "setCpuWaiting\n");
    // }
    // else
    // {
    //   owner->cpuWaiting = false;
    //   owner->memPort.sendRetryResp();
    // }
    // return success;
  }

  bool SecureModule::CPUSidePort::sendPacketQueue()
  {
    DPRINTF(SecureModuleCpp, "sendPacketQueue\n");
    DPRINTF(SecureModuleCpp, "responseQueue.size: %d\n", owner->responseQueue.size());

    if (owner->cpuBlocked)
    {
      DPRINTF(SecureModuleCpp, "⚠️ CPU is blocked. Need to wait for a retry before attempting\n");
      return false;
    }
    if (owner->responseQueue.empty())
    {
      DPRINTF(SecureModuleCpp, "⚠️ responseQueue is empty. nothing to send\n");
      return false;
    }

    PacketPtr pkt = owner->responseQueue.front();
    bool succ = sendTimingResp(pkt);
    if (!succ) // return false, retry request will come later
    {
      DPRINTF(SecureModuleCpp, "❌ CPU denied packet %s\n", pkt->print());
      owner->cpuBlocked = true;
    }
    else
    { // succesful send
      owner->responseQueue.pop();
      DPRINTF(SecureModuleCpp, "✅ CPU accepted packet %s\n", pkt->print());

      // schedule a send of the next packet
      // owner->schedule(new EventFunctionWrapper([this]
      //                                          { sendPacketQueue(); },
      //                                          name() + ".accessEvent", true),
      //                 owner->clockEdge(static_cast<Cycles>(1)));
    }
    return succ;
  }

  void SecureModule::CPUSidePort::recvFunctional(PacketPtr pkt)
  {
    // DPRINTF(SecureModuleCpp, "recvFunctional\n");
    // Just forward to the memobj.
    return owner->handleFunctional(pkt);
  }

  bool SecureModule::CPUSidePort::recvTimingReq(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "➡️️recvTimingReq, pkt-> %s\n", pkt->print());
    return owner->handleRequest(pkt);
  }

  void SecureModule::CPUSidePort::recvRespRetry()
  {
    DPRINTF(SecureModuleCpp, "recvRespRetry\n");
    owner->pendingRequest = false;
    owner->cpuBlocked = false;
    // owner->handleCpuRetry();
    // sendPacketQueue(); // attempts to send the front packet of the queue
  }

  // PLAN TO DEPRECATE
  bool SecureModule::MemSidePort::sendPacket(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "sendPacket\n");
    bool succ = sendTimingReq(pkt);
    if (!succ) // return false, retry request will come later
    {
      owner->state = ModuleState::MEM_WAITING_RETRY;
      DPRINTF(SecureModuleCpp, "memory denied packet, entering state MEM_WAITING_RETRY\n");
      DPRINTF(SecureModuleCpp, "❌ Memory denied packet %s", pkt->print());
    }
    else
    { // succesful send
      owner->state = ModuleState::MEM_WAITING_RESPONSE;
      DPRINTF(SecureModuleCpp, "✅ Memory accepted packet %s\n", pkt->print());
    }
    return succ;
  }

  // similar to regular sendpacket, references request queue instead of a single packet
  bool SecureModule::MemSidePort::sendPacketQueue()
  {
    DPRINTF(SecureModuleCpp, "sendPacketQueue\n");
    DPRINTF(SecureModuleCpp, "requestQueue.size: %d\n", owner->requestQueue.size());

    if (owner->memBlocked)
    {
      DPRINTF(SecureModuleCpp, "Memory is blocked. Need to wait for a retry before attempting\n");
      return false;
    }
    if (owner->requestQueue.empty())
    {
      DPRINTF(SecureModuleCpp, "⚠️ requestQueue is empty. nothing to send\n");
      return false;
    }

    PacketPtr pkt = std::get<0>(owner->requestQueue.front());
    bool succ = sendTimingReq(pkt);
    if (!succ) // return false, retry request will come later
    {
      owner->state = ModuleState::MEM_WAITING_RETRY;
      DPRINTF(SecureModuleCpp, "memory denied packet, entering state MEM_WAITING_RETRY\n");
      DPRINTF(SecureModuleCpp, "❌ Memory denied packet %s", pkt->print());
      owner->memBlocked = true;
    }
    else
    { // succesful send
      owner->state = ModuleState::MEM_WAITING_RESPONSE;
      owner->requestQueue.pop();
      DPRINTF(SecureModuleCpp, "✅ Memory accepted packet %s\n", pkt->print());

      // schedule a send of the next packet
      // owner->schedule(new EventFunctionWrapper([this]
      //                                          { sendPacketQueue(); },
      //                                          name() + ".accessEvent", true),
      //                 owner->clockEdge(static_cast<Cycles>(1)));

      // owner->handleCpuReqRetry();
    }
    return succ;
  }

  bool SecureModule::MemSidePort::recvTimingResp(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "⬅️ recvTimingResp\n");
    return owner->handleResponse(pkt);
  }

  void SecureModule::MemSidePort::recvReqRetry()
  {
    DPRINTF(SecureModuleCpp, "recvReqRetry\n");
    DPRINTF(SecureModuleCpp, "Module state: %d\n", owner->state);
    owner->pendingResponse = false;
    owner->memBlocked = false;
    // owner->handleMemRetry();
    // We should have a blocked packet if this function is called.
    // assert(blockedPacket != nullptr);
    sendPacketQueue();
  }

  void SecureModule::MemSidePort::recvRangeChange()
  {
    DPRINTF(SecureModuleCpp, "recvRangeChange\n");
    owner->sendRangeChange();
  }

  // secure module main methods
  void SecureModule::handleCpuReqRetry()
  {
    if (pendingRequest)
    {
      DPRINTF(SecureModuleCpp, "Sending CPU request retry\n");
      pendingRequest = false;
      cpuPort.sendRetryReq();
      return;
    }
  }

  void SecureModule::handleMemRespRetry()
  {
    if (pendingResponse)
    {
      DPRINTF(SecureModuleCpp, "Sending MEM response retry\n");
      pendingResponse = false;
      memPort.sendRetryResp();
      return;
    }
  }

  bool SecureModule::handleRequest(PacketPtr pkt)
  {
    DPRINTF(SecureModule, "%s for addr %#x\n", pkt->cmdString(), pkt->getAddr());
    DPRINTF(SecureModuleCpp, "handleRequest . pkt-type: %s for addr %#x\n", pkt->cmdString(), pkt->getAddr());
    // DPRINTF(SecureModuleCpp, "Module State: %d\n", state);
    // DPRINTF(SecureModuleCpp, "needsResponse: %d\n", pkt->needsResponse());

    // bool succ = enqueueRequest(pkt);
    bool *b = new bool(false);
    std::tuple<PacketPtr, bool *> p = std::make_tuple(pkt, b);
    bool succ = requestQueue.push(p);
    if (!succ)
    {
      DPRINTF(SecureModuleCpp, "enqueueRequest failed\n");
      pendingRequest = true;
    }
    else
    {
      // assert(pendingRequest == false);
      pendingRequest = false; // by virtue of the queue having space
      DPRINTF(SecureModuleCpp, "enqueueRequest success\n");
      // add to the event queue to process a request from the queue

      Tick delay = clockEdge(mem_issue_latency + static_cast<Cycles>(1));
      DPRINTF(SecureModuleCpp, "scheduling for tick %d\n", delay);
      schedule(new EventFunctionWrapper([this, b]
                                        { setPacketReady(b); },
                                        name() + ".accessEvent", true),
               delay); // TODO: update this hardcoded value to a param
    }
    return succ;
  }

  bool SecureModule::handleResponse(PacketPtr pkt)
  {
    DPRINTF(SecureModule, "Got response for addr %#x\n", pkt->getAddr());
    DPRINTF(SecureModuleCpp, "handleResponse. pkt-type: %s\n", pkt->cmdString());

    // we got here because memPort.recvTimingResp was called.
    // either we succesfully add pkt to respons queue or we return false to sender
    // and ask for a retry later when we're ready
    bool succ = responseQueue.push(pkt);
    if (!succ)
    {
      DPRINTF(SecureModuleCpp, "enqueueResponse failed\n");
      pendingResponse = true;
    }
    else
    {
      // assert(pendingResponse == false);
      pendingResponse = false; // by virtue of the queue having space
      DPRINTF(SecureModuleCpp, "enqueueResponse success\n");
      // add to the event queue to process a response from the queue
      // we don't need to delay the response packet so we add that call to the
      // event queue with no additional delay
      // schedule(new EventFunctionWrapper([this]
      //                                   { cpuPort.sendPacketQueue(); },
      //                                   name() + ".accessEvent", true),
      //          curTick()); // TODO: update this hardcoded value to a param
    }
    return succ;
  }

  void SecureModule::setPacketReady(bool *b)
  {
    // simple function that sets a flag to true
    DPRINTF(SecureModuleCpp, "setPacketReady\n");
    *b = true;
  }

  void SecureModule::unBlock(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "unBlock: waiting type %d\n", waiting);
    // DPRINTF(SecureModuleCpp, "unBlock. pkt-type: %s\n", pkt->cmdString());
    blocked = false;
    if (waiting)
    {
      cpuPort.sendRetryReq();
      waiting = false;
    }
  }

  // do we need these?
  bool SecureModule::enqueueRequest(PacketPtr pkt)
  {
  }

  bool SecureModule::enqueueResponse(PacketPtr pkt)
  {
  }

  void SecureModule::cleanReady()
  {
    DPRINTF(SecureModuleCpp, "cleanReady\n");
    // should not execute here if we are not in the ready state
    assert(state == ModuleState::READY);
    if (cpuWaiting)
    {
      DPRINTF(SecureModuleCpp, "sendingRetyReq\n");
      cpuPort.sendRetryReq();
    }
  }

  void SecureModule::handleFunctional(PacketPtr pkt)
  {
    // DPRINTF(SecureModuleCpp, "handleFunctional\n");
    // Just pass this on to the memory side to handle for now.
    memPort.sendFunctional(pkt);
  }

  AddrRangeList SecureModule::getAddrRanges() const
  {
    DPRINTF(SecureModuleCpp, "getAddrRanges\n");
    DPRINTF(SecureModule, "Sending new ranges\n");
    // Just use the same ranges as whatever is on the memory side.
    return memPort.getAddrRanges();
  }

  void SecureModule::sendRangeChange()
  {
    DPRINTF(SecureModuleCpp, "sendRangeChange\n");
    cpuPort.sendRangeChange();
    // for (auto &port : cpuPorts) {
    //   port.sendRangeChange();
    // }
  }

} // namespace gem5
