import concurrent.futures
import os
import pdb
import subprocess
import sys
from itertools import product

# a string with 3 arguments
cmd = "build/X86/gem5.debug --outdir={}/ configs/malware_detection/latest.py --binary {} --sm_cache_hitrate {}"
base_run_name = "test/ooo/w_sm_1q"  # TODO: change this beteween runs!


bin_path_base = "microbench/"
binaries = [
    "mm",
    # "lfsr",
    # "merge",
    # "sieve",
    # "spmv"
]

hit_rates = [
    0.0,
    #  0.1,
    #  0.2,
    #  0.3,
    #  0.4,
    #  0.5,
    #  0.6,
    #  0.7,
    #  0.8,
    #  0.9,
    #  1.0
]
run_params = list(product(binaries, hit_rates))
print("Run Params", run_params)

# for params in run_params:
#     print(params)
#     print("here")

#     run_base_name = params[0]
#     cache_hit_rate = params[1]

#     # get all directories in the run_base_name folder
#     print('f')
#     dirs = os.walk(run_base_name)
#     try:
#         d = next(dirs)[1]
#         print("folder found!")
#         print("sub directories:", d)
#     except:
#         # make the dir
#         print("No folder", run_base_name)
#         pass


# directory naming


def find_unique_dir_name(base_dir_name):
    counter = 1
    new_dir_name = base_dir_name

    while os.path.isdir(new_dir_name):
        new_dir_name = f"{base_dir_name}_{counter}"
        counter += 1

    return new_dir_name


def execute_binary(params):
    # pdb.set_trace()
    print("Thread params", params)

    benchmark = params[0]
    cache_hit_rate = params[1]
    run_name = (
        "runs/" + base_run_name + "/" + benchmark + "_" + str(cache_hit_rate)
    )

    cmd_string = cmd.format(
        run_name, bin_path_base + benchmark, str(params[1])
    )

    # check if there is already a directory that matche the run_name
    unique_dir = find_unique_dir_name(run_name)

    result = subprocess.run(
        cmd_string, shell=True, check=True, stderr=subprocess.PIPE
    )


with concurrent.futures.ThreadPoolExecutor() as executor:
    executor.map(execute_binary, run_params)
